<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>this关键字 | web开发</title>
    <meta name="description" content="web开发总结|JavaScript|React|Vue|node|go">
    
    
    <link rel="preload" href="/assets/css/0.styles.87ef2d23.css" as="style"><link rel="preload" href="/assets/js/app.617206ce.js" as="script"><link rel="preload" href="/assets/js/6.2eb0d903.js" as="script"><link rel="prefetch" href="/assets/js/7.fa6178b1.js"><link rel="prefetch" href="/assets/js/1.fe3eea68.js"><link rel="prefetch" href="/assets/js/2.3205063b.js"><link rel="prefetch" href="/assets/js/3.1049ef07.js"><link rel="prefetch" href="/assets/js/4.00fcc2ac.js"><link rel="prefetch" href="/assets/js/5.2c558942.js"><link rel="prefetch" href="/assets/js/8.1d94c8f5.js"><link rel="prefetch" href="/assets/js/9.44b188d1.js"><link rel="prefetch" href="/assets/js/10.4ded16a5.js"><link rel="prefetch" href="/assets/js/11.f53590f7.js"><link rel="prefetch" href="/assets/js/12.8d0596cb.js"><link rel="prefetch" href="/assets/js/13.17ed76c8.js"><link rel="prefetch" href="/assets/js/14.31de5b3e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.87ef2d23.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><main data-v-52c4739b><nav class="menu" data-v-52c4739b><ul class="container" data-v-52c4739b><li class="active" data-v-52c4739b><a href="/" class="router-link-active" data-v-52c4739b>home</a></li><li data-v-52c4739b><a href="/category/" data-v-52c4739b>分类</a></li><!----><li data-v-52c4739b><a href="/person/" data-v-52c4739b>关于</a></li></ul></nav><div class="container" data-v-52c4739b><div class="content custom markdown-body" data-v-52c4739b><h1 id="this关键字"><a href="#this关键字" aria-hidden="true" class="header-anchor">#</a> this关键字</h1><h2 id="目录"><a href="#目录" aria-hidden="true" class="header-anchor">#</a> 目录</h2><h2 id="为什么使用this"><a href="#为什么使用this" aria-hidden="true" class="header-anchor">#</a> 为什么使用this</h2><blockquote><p>this 提供了一种更优雅的方式来隐式“ 传递” 一个对象引用， 因此可以将 API 设计
得更加简洁并且易于复用</p></blockquote><h2 id="this指向的是什么"><a href="#this指向的是什么" aria-hidden="true" class="header-anchor">#</a> this指向的是什么</h2><blockquote><p>this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。this是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。</p></blockquote><h2 id="调用位置"><a href="#调用位置" aria-hidden="true" class="header-anchor">#</a> 调用位置</h2><blockquote><p>调用位置就是函数在代码中被调用的位置（ 而不是声明的位置）;只有仔细分析调用位置才能回答这个问题： 这个 this 到底引
用的是什么？</p></blockquote><ol><li><p>独立函数调用。 this指向全局对象，如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined</p></li><li><p>隐式绑定。 调用位置是否有上下文对象， 或者说是否被某个对象拥有或者包含 ， this指向这个对象</p></li></ol><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><ol start="3"><li>隐试丢失。 最常见的隐试丢失</li></ol><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// 函数别名！</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// a 是全局对象的属性</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre></div><ol start="4"><li>显示绑定this。</li></ol><blockquote><p>call()和apply() 都能调用函数，并且改变函数this指向;</p></blockquote><blockquote><p>bind内置方法会返回一个新函数，并绑定好this;</p></blockquote><blockquote><p>new绑定。把构造函数的this绑定到构造的新对象上;</p></blockquote><h2 id="综上-判断this的步骤总结为"><a href="#综上-判断this的步骤总结为" aria-hidden="true" class="header-anchor">#</a> 综上 判断this的步骤总结为</h2><ol><li>函数是否在 new 中调用（ new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。
var bar = new foo()</li><li>函数是否通过 call、 apply（ 显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是
指定的对象。
var bar = foo.call(obj2)</li><li>函数是否在某个上下文对象中调用（ 隐式绑定） ？ 如果是的话， this 绑定的是那个上
下文对象。
var bar = obj1.foo()</li><li>如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到
全局对象。
var bar = foo()</li></ol><h2 id="绑定例外"><a href="#绑定例外" aria-hidden="true" class="header-anchor">#</a> 绑定例外</h2><ol><li>把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则</li></ol></div></div><div class="menu-btn" data-v-60aea5a8 data-v-52c4739b><section class="mod model menu-icon" data-v-60aea5a8><div class="menu" data-v-60aea5a8><div class="bar" data-v-60aea5a8></div><div class="bar" data-v-60aea5a8></div><div class="bar" data-v-60aea5a8></div></div></section></div></main></div>
    <script src="/assets/js/6.2eb0d903.js" defer></script><script src="/assets/js/app.617206ce.js" defer></script>
  </body>
</html>
