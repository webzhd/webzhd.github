(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{119:function(t,a,s){"use strict";s.r(a);var e=s(3),i=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"this关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this关键字","aria-hidden":"true"}},[t._v("#")]),t._v(" this关键字")]),s("h2",{attrs:{id:"目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录","aria-hidden":"true"}},[t._v("#")]),t._v(" 目录")]),s("h2",{attrs:{id:"为什么使用this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用this","aria-hidden":"true"}},[t._v("#")]),t._v(" 为什么使用this")]),s("blockquote",[s("p",[t._v("this 提供了一种更优雅的方式来隐式“ 传递” 一个对象引用， 因此可以将 API 设计\n得更加简洁并且易于复用")])]),s("h2",{attrs:{id:"this指向的是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this指向的是什么","aria-hidden":"true"}},[t._v("#")]),t._v(" this指向的是什么")]),s("blockquote",[s("p",[t._v("this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。this是在函数被调用时发生的绑定， 它指向什么完全取决于函数在哪里被调用。")])]),s("h2",{attrs:{id:"this的一些默认规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的一些默认规则","aria-hidden":"true"}},[t._v("#")]),t._v(" this的一些默认规则")]),s("blockquote",[s("p",[t._v("在函数中，this指向全局对象，如果使用严格模式（ strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined")])]),s("h2",{attrs:{id:"隐试绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隐试绑定","aria-hidden":"true"}},[t._v("#")]),t._v(" 隐试绑定")])])}],!1,null,null,null);a.default=i.exports}}]);