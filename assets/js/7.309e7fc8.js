(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{116:function(a,r,t){"use strict";t.r(r);var e=t(3),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"javascript作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript作用域","aria-hidden":"true"}},[a._v("#")]),a._v(" JavaScript作用域")]),t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录","aria-hidden":"true"}},[a._v("#")]),a._v(" 目录")]),t("ol",[t("li",[t("p",[t("a",{attrs:{href:"#rhs%E5%92%8Clhs"}},[a._v("RHS和LHS")])])]),t("li",[t("p",[t("a",{attrs:{href:"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F"}},[a._v("什么是作用域")])])]),t("li",[t("p",[t("a",{attrs:{href:"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99"}},[a._v("作用域嵌套规则")])])]),t("li",[t("p",[t("a",{attrs:{href:"#%E6%9F%A5%E8%AF%A2%E5%BC%82%E5%B8%B8"}},[a._v("查询异常")])])]),t("li",[t("p",[t("a",{attrs:{href:"#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"}},[a._v("变量提升")])])])]),t("br"),t("h2",{attrs:{id:"rhs和lhs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rhs和lhs","aria-hidden":"true"}},[a._v("#")]),a._v(" RHS和LHS")]),t("blockquote",[t("p",[a._v("当变量出现在赋值操作的左侧时进行 LHS 查询, 其他为 RHS 查询，RHS 查询与简单地查找某个变量的值别无二致， 而 LHS 查询则是试图找到变量的容器本身， 从而可以对其赋值\n"),t("br")])]),t("h2",{attrs:{id:"什么是作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是作用域","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是作用域")]),t("blockquote",[t("p",[a._v("负责收集并维护由所有声明的标识符（ 变量） 组成的一系列查\n询， 并实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限。\n"),t("br")])]),t("h2",{attrs:{id:"作用域嵌套规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域嵌套规则","aria-hidden":"true"}},[a._v("#")]),a._v(" 作用域嵌套规则")]),t("blockquote",[t("p",[a._v("作用域是根据名称查找变量的一套规则。 实际情况中， 通常需要同时顾及几个作用域。当一个块或函数嵌套在另一个块或函数中时， 就发生了作用域的嵌套。引擎从当前的执行作用域开始查找变量， 如果找不到，就向上一级继续查找。 当抵达最外层的全局作用域时， 无论找到还是没找到， 查找过程都\n会停止。\n"),t("br")])]),t("h2",{attrs:{id:"查询异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询异常","aria-hidden":"true"}},[a._v("#")]),a._v(" 查询异常")]),t("blockquote",[t("p",[a._v("如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量， 引擎就会抛出 ReferenceError异常。 值得注意的是， ReferenceError 是非常重要的异常类型。相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎。\n"),t("br")])]),t("h2",{attrs:{id:"变量提升"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量提升","aria-hidden":"true"}},[a._v("#")]),a._v(" 变量提升")]),t("blockquote",[t("p",[a._v("函数声明和变量声明都会被提升，但是函数会首先被提升， 然后才是变量。我们习惯将 var a = 2; 看作一个声明， 而实际上 JavaScript 引擎并不这么认为。 它将 var a和 a = 2 当作两个单独的声明， 第一个是编译阶段的任务， 而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方， 都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（ 变量和函数） 都会被“ 移动”到各自作用域的最顶端， 这个过程被称为提升。")])]),t("blockquote",[t("p",[a._v("声明本身会被提升， 而包括函数表达式的赋值在内的赋值操作并不会提升。")])]),t("br"),a._v("\n> 平日总结，仅供参考\n")])}],!1,null,null,null);r.default=s.exports}}]);